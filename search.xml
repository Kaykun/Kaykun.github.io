<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用Windows10内置PowerShell连接虚拟机Linux系统</title>
    <url>/2020/02/24/%E4%BD%BF%E7%94%A8Windows10%E5%86%85%E7%BD%AEPowerShell%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BALinux%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info"><p>为了学习和使用Linux，多数人选择了使用虚拟机的方式来安装Linux。</p></div>虚拟机的选择可以参考：<a href="https://www.10besty.com/best-virtual-machine-applications/" target="_blank" rel="noopener external nofollow noreferrer"> 2020年最好的虚拟机测评推荐</a><p>​我之前使用的<a href="https://store.vmware.com/store?Action=home&amp;Env=BASE&amp;Locale=zh_CN&amp;SiteID=vmware" target="_blank" rel="noopener external nofollow noreferrer">VMware Workstation Pro</a>，但是因为体积大需要激活码注册，所以我现在现阶段选择使用的是Virtualbox，轻量级并且免费，功能方面成熟也齐全。VirtualBox提供了多种网络连接方式，不同的网络连接方式决定了虚拟机是否可以联网，以及是否可以和宿主机互相ping通。本文将主要介绍常用的桥接、NAT和host-only三种网络连接方式的区别，以减少大家在使用中的困扰。</p><a id="more"></a><h4 id="一、不同网络连接方式对网络影响简介"><a href="#一、不同网络连接方式对网络影响简介" class="headerlink" title="一、不同网络连接方式对网络影响简介"></a>一、不同网络连接方式对网络影响简介</h4><table><thead><tr><th></th><th>桥接</th><th>NAT</th><th>host-only</th></tr></thead><tbody><tr><td>虚拟机与宿主机</td><td>彼此互通，处于同一网段</td><td>虚拟机能访问宿主机；宿主机不能访问虚拟机</td><td>虚拟机不能访问宿主机；宿主机能访问虚拟机</td></tr><tr><td>虚拟机与虚拟机</td><td>彼此互通，处于同一网段</td><td>彼此不通</td><td>彼此互通，处于同一网段</td></tr><tr><td>虚拟机与其他主机</td><td>彼此互通，处于同一网段</td><td>虚拟机能访问其他主机；其他主机不能访问虚拟机</td><td>彼此不通；需要设置</td></tr><tr><td>虚拟机与互联网</td><td>虚拟机可以上网</td><td>虚拟机可以上网</td><td>彼此不通；需要设置</td></tr></tbody></table><h4 id="二、virtualbox视图快捷键说明"><a href="#二、virtualbox视图快捷键说明" class="headerlink" title="二、virtualbox视图快捷键说明"></a>二、virtualbox视图快捷键说明</h4><p>刚才因为无意触碰到全屏模式导致整个页面分辨率都模糊难触控，搜了半天才退出，记录下：<br>首先说明一下，Virtualbox中默认的host键是右ctrl，调出快捷菜单的组合键是host+home，这个请记住，因为在有的显示模式下是不显示菜单的。<br>‘视图’菜单下共有5个选项，分别是：</p><ul><li><p>切换到全屏模式 HOST+F</p></li><li><p>切换到无缝模式 HOST+L</p></li><li><p>切换到自动缩放模式 HOST+C</p></li><li><p>自动调整显示尺寸 HOST+G</p></li><li><p>自动调整窗口大小 HOST+A</p></li></ul><p>每个选项前都有个小图标，如果小图标上显示一个对号，意思就是打开了这个选项。注意无缝模式和自动调整显示尺寸需要guest additions支持，所以非windows的虚拟机里这两个选项是灰色的。</p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 8</title>
    <url>/2020/02/22/CentOS8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><h4 id="CentOS-8-的新特性"><a href="#CentOS-8-的新特性" class="headerlink" title="CentOS 8 的新特性"></a>CentOS 8 的新特性</h4></blockquote><ul><li>DNF 成为了默认的软件包管理器，同时 yum 仍然是可用的</li><li>使用网络管理器（<code>nmcli</code> 和 <code>nmtui</code>）进行网络配置，移除了网络脚本</li><li>使用 Podman 进行容器管理</li><li>引入了两个新的包仓库：BaseOS 和 AppStream</li><li>使用 Cockpit 作为默认的系统管理工具</li><li>默认使用 Wayland 作为显示服务器</li><li><code>iptables</code> 将被 <code>nftables</code> 取代</li><li>使用 Linux 内核 4.18</li><li>提供 PHP 7.2、Python 3.6、Ansible 2.8、VIM 8.0 和 Squid 4</li></ul><a id="more"></a><blockquote><h4 id="CentOS-8-所需的最低硬件配置"><a href="#CentOS-8-所需的最低硬件配置" class="headerlink" title="CentOS 8 所需的最低硬件配置"></a>CentOS 8 所需的最低硬件配置</h4></blockquote><ul><li>2 GB RAM</li><li>64 位 x86 架构、2 GHz 或以上的 CPU</li><li>20 GB 硬盘空间</li></ul><blockquote><h4 id="镜像下载地址"><a href="#镜像下载地址" class="headerlink" title="镜像下载地址"></a>镜像下载地址</h4></blockquote><p>CentOS 8 下载：<a href="https://centos.org/download/" target="_blank" rel="noopener external nofollow noreferrer">https://centos.org/download/</a></p><p>国内镜像下载：<a href="https://mirrors.tuna.tsinghua.edu.cn/centos/" target="_blank" rel="noopener external nofollow noreferrer">https://mirrors.tuna.tsinghua.edu.cn/centos/</a></p><blockquote><h3 id="CentOS配置阿里云yum源和epel源"><a href="#CentOS配置阿里云yum源和epel源" class="headerlink" title="CentOS配置阿里云yum源和epel源"></a>CentOS配置阿里云yum源和epel源</h3></blockquote><p># cd /etc/yum.repos.d</p><img src="/2020/02/22/CentOS8/Aliyun.png" title="Aliyun"><p># vim CentOS-AppStream.repo<br><strong>baseurl=<a href="https://mirrors.aliyun.com/centos/$releasever/AppStream/$basearch/os/" target="_blank" rel="noopener external nofollow noreferrer">https://mirrors.aliyun.com/centos/$releasever/AppStream/$basearch/os/</a></strong></p><img src="/2020/02/22/CentOS8/AppStream.png" title="AppStream"><p># vim CentOS-Base.repo<br><strong>baseurl=<a href="https://mirrors.aliyun.com/centos/$releasever/BaseOS/$basearch/os/" target="_blank" rel="noopener external nofollow noreferrer">https://mirrors.aliyun.com/centos/$releasever/BaseOS/$basearch/os/</a></strong></p><img src="/2020/02/22/CentOS8/BaseOS.png" title="BaseOS"><p># vim CentOS-Extras.repo<br><strong>baseurl=<a href="https://mirrors.aliyun.com/centos/$releasever/extras/$basearch/os/" target="_blank" rel="noopener external nofollow noreferrer">https://mirrors.aliyun.com/centos/$releasever/extras/$basearch/os/</a></strong></p><img src="/2020/02/22/CentOS8/Extras.png" title="Extras"><p># dnf -y install epel-release<br># dnf clean all<br># dnf makecache<br># dnf repolist</p><img src="/2020/02/22/CentOS8/DNF.png" title="epel"><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>git使用教程</title>
    <url>/2020/02/15/Git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info"><p>由于最近使用Hexo+GitPage搭建博客 使用Git命令比较多 故将Git使用方法写一篇总结。</p></div><a id="more"></a><p><strong>一、 Git 常用命令速查</strong></p><p>git branch 查看本地所有分支<br>git status 查看当前状态<br>git commit 提交<br>git branch -a 查看所有的分支<br>git branch -r 查看远程所有分支<br>git commit -am “init” 提交并且加注释<br>git remote add origin <a href="mailto:git@192.168.1.119" rel="external nofollow noreferrer">git@192.168.1.119</a>:ndshow<br>git push origin master 将文件给推到服务器上<br>git remote show origin 显示远程库origin里的资源<br>git push origin master:develop<br>git push origin master:hb-dev 将本地库与服务器上的库进行关联<br>git checkout –track origin/dev 切换到远程dev分支<br>git branch -D master develop 删除本地库develop<br>git checkout -b dev 建立一个新的本地分支dev<br>git merge origin/dev 将分支dev与当前分支进行合并<br>git checkout dev 切换到本地dev分支<br>git remote show 查看远程库<br>git add .<br>git rm 文件名(包括路径) 从git中删除指定文件<br>git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来<br>git config –list 看所有用户<br>git ls-files 看已经被提交的<br>git rm [file name] 删除一个文件<br>git commit -a 提交当前repos的所有的改变<br>git add [file name] 添加一个文件到git index<br>git commit -v 当你用－v参数的时候可以看commit的差异<br>git commit -m “This is the message describing the commit” 添加commit信息<br>git commit -a -a是代表add，把所有的change加到git index里然后再commit<br>git commit -a -v 一般提交命令<br>git log 看你commit的日志<br>git diff 查看尚未暂存的更新<br>git rm a.a 移除文件(从暂存区和工作区中删除)<br>git rm –cached a.a 移除文件(只从暂存区中删除)<br>git commit -m “remove” 移除文件(从Git中删除)<br>git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)<br>git diff –cached 或 $ git diff –staged 查看尚未提交的更新<br>git stash push 将文件给push到一个临时空间中<br>git stash pop 将文件从临时空间pop下来<br>-——————————————————–<br>git remote add origin <a href="mailto:git@github.com" rel="external nofollow noreferrer">git@github.com</a>:username/Hello-World.git<br>git push origin master 将本地项目给提交到服务器中<br>-———————————————————-<br>git pull 本地与服务器端同步<br>-—————————————————————-<br>git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。<br>git push origin serverfix:awesomebranch<br>-—————————————————————–<br>git fetch 相当于是从远程获取最新版本到本地，不会自动merge<br>git commit -a -m “log_message” (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：<br>git branch branch_0.1 master 从主分支master创建branch_0.1分支<br>git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0<br>git checkout branch_1.0/master 切换到branch_1.0/master分支<br>du -hs</p><p>git branch 删除远程branch<br>git push origin :branch_remote_name<br>git branch -r -d branch_remote_name<br>-———————————————————-</p><p>初始化版本库，并提交到远程服务器端<br>mkdir WebApp<br>cd WebApp<br>git init 本地初始化<br>touch README<br>git add README 添加文件<br>git commit -m ‘first commit’<br>git remote add origin <a href="mailto:git@github.com" rel="external nofollow noreferrer">git@github.com</a>:daixu/WebApp.git</p><p>增加一个远程服务器端</p><p>上面的命令会增加URL地址为‘git@github.com:daixu/WebApp.git’，名称为origin的远程服务器库，以后提交代码的时候只需要使用 origin别名即可</p><h2 id="二、-Git-命令速查表"><a href="#二、-Git-命令速查表" class="headerlink" title="二、 Git 命令速查表"></a><strong>二、 Git 命令速查表</strong></h2><h3 id="1、常用的Git命令"><a href="#1、常用的Git命令" class="headerlink" title="1、常用的Git命令"></a>1、常用的Git命令</h3><table><thead><tr><th><strong><em>\</em>命令**</strong></th><th><strong><em>\</em>简要说明**</strong></th></tr></thead><tbody><tr><td>git add</td><td>添加至暂存区</td></tr><tr><td>git add–interactive</td><td>交互式添加</td></tr><tr><td>git apply</td><td>应用补丁</td></tr><tr><td>git am</td><td>应用邮件格式补丁</td></tr><tr><td>git annotate</td><td>同义词，等同于 git blame</td></tr><tr><td>git archive</td><td>文件归档打包</td></tr><tr><td>git bisect</td><td>二分查找</td></tr><tr><td>git blame</td><td>文件逐行追溯</td></tr><tr><td>git branch</td><td>分支管理</td></tr><tr><td>git cat-file</td><td>版本库对象研究工具</td></tr><tr><td>git checkout</td><td>检出到工作区、切换或创建分支</td></tr><tr><td>git cherry-pick</td><td>提交拣选</td></tr><tr><td>git citool</td><td>图形化提交，相当于 git gui 命令</td></tr><tr><td>git clean</td><td>清除工作区未跟踪文件</td></tr><tr><td>git clone</td><td>克隆版本库</td></tr><tr><td>git commit</td><td>提交</td></tr><tr><td>git config</td><td>查询和修改配置</td></tr><tr><td>git describe</td><td>通过里程碑直观地显示提交ID</td></tr><tr><td>git diff</td><td>差异比较</td></tr><tr><td>git difftool</td><td>调用图形化差异比较工具</td></tr><tr><td>git fetch</td><td>获取远程版本库的提交</td></tr><tr><td>git format-patch</td><td>创建邮件格式的补丁文件。参见 git am 命令</td></tr><tr><td>git grep</td><td>文件内容搜索定位工具</td></tr><tr><td>git gui</td><td>基于Tcl/Tk的图形化工具，侧重提交等操作</td></tr><tr><td>git help</td><td>帮助</td></tr><tr><td>git init</td><td>版本库初始化</td></tr><tr><td>git init-db*</td><td>同义词，等同于 git init</td></tr><tr><td>git log</td><td>显示提交日志</td></tr><tr><td>git merge</td><td>分支合并</td></tr><tr><td>git mergetool</td><td>图形化冲突解决</td></tr><tr><td>git mv</td><td>重命名</td></tr><tr><td>git pull</td><td>拉回远程版本库的提交</td></tr><tr><td>git push</td><td>推送至远程版本库</td></tr><tr><td>git rebase</td><td>分支变基</td></tr><tr><td>git rebase–interactive</td><td>交互式分支变基</td></tr><tr><td>git reflog</td><td>分支等引用变更记录管理</td></tr><tr><td>git remote</td><td>远程版本库管理</td></tr><tr><td>git repo-config*</td><td>同义词，等同于 git config</td></tr><tr><td>git reset</td><td>重置改变分支“游标”指向</td></tr><tr><td>git rev-parse</td><td>将各种引用表示法转换为哈希值等</td></tr><tr><td>git revert</td><td>反转提交</td></tr><tr><td>git rm</td><td>删除文件</td></tr><tr><td>git show</td><td>显示各种类型的对象</td></tr><tr><td>git stage*</td><td>同义词，等同于 git add</td></tr><tr><td>git stash</td><td>保存和恢复进度</td></tr><tr><td>git status</td><td>显示工作区文件状态</td></tr><tr><td>git tag</td><td>里程碑管理</td></tr></tbody></table><h3 id="2、对象库操作相关命令"><a href="#2、对象库操作相关命令" class="headerlink" title="2、对象库操作相关命令"></a>2、对象库操作相关命令</h3><table><thead><tr><th><strong><em>\</em>命令**</strong></th><th><strong><em>\</em>简要说明**</strong></th></tr></thead><tbody><tr><td>git commit-tree</td><td>从树对象创建提交</td></tr><tr><td>git hash-object</td><td>从标准输入或文件计算哈希值或创建对象</td></tr><tr><td>git ls-files</td><td>显示工作区和暂存区文件</td></tr><tr><td>git ls-tree</td><td>显示树对象包含的文件</td></tr><tr><td>git mktag</td><td>读取标准输入创建一个里程碑对象</td></tr><tr><td>git mktree</td><td>读取标准输入创建一个树对象</td></tr><tr><td>git read-tree</td><td>读取树对象到暂存区</td></tr><tr><td>git update-index</td><td>工作区内容注册到暂存区及暂存区管理</td></tr><tr><td>git unpack-file</td><td>创建临时文件包含指定 blob 的内容</td></tr><tr><td>git write-tree</td><td>从暂存区创建一个树对象</td></tr></tbody></table><h3 id="3、引用操作相关命令"><a href="#3、引用操作相关命令" class="headerlink" title="3、引用操作相关命令"></a>3、引用操作相关命令</h3><table><thead><tr><th><strong><em>\</em>命令**</strong></th><th><strong><em>\</em>简要说明**</strong></th></tr></thead><tbody><tr><td>git check-ref-format</td><td>检查引用名称是否符合规范</td></tr><tr><td>git for-each-ref</td><td>引用迭代器，用于shell编程</td></tr><tr><td>git ls-remote</td><td>显示远程版本库的引用</td></tr><tr><td>git name-rev</td><td>将提交ID显示为友好名称</td></tr><tr><td>git peek-remote*</td><td>过时命令，请使用 git ls-remote</td></tr><tr><td>git rev-list</td><td>显示版本范围</td></tr><tr><td>git show-branch</td><td>显示分支列表及拓扑关系</td></tr><tr><td>git show-ref</td><td>显示本地引用</td></tr><tr><td>git symbolic-ref</td><td>显示或者设置符号引用</td></tr><tr><td>git update-ref</td><td>更新引用的指向</td></tr><tr><td>git verify-tag</td><td>校验 GPG 签名的Tag</td></tr></tbody></table><h3 id="4、版本库管理相关命令"><a href="#4、版本库管理相关命令" class="headerlink" title="4、版本库管理相关命令"></a>4、版本库管理相关命令</h3><table><thead><tr><th><strong><em>\</em>命令**</strong></th><th><strong><em>\</em>简要说明**</strong></th></tr></thead><tbody><tr><td>git count-objects</td><td>显示松散对象的数量和磁盘占用</td></tr><tr><td>git filter-branch</td><td>版本库重构</td></tr><tr><td>git fsck</td><td>对象库完整性检查</td></tr><tr><td>git fsck-objects*</td><td>同义词，等同于 git fsck</td></tr><tr><td>git gc</td><td>版本库存储优化</td></tr><tr><td>git index-pack</td><td>从打包文件创建对应的索引文件</td></tr><tr><td>git lost-found*</td><td>过时，请使用 git fsck –lost-found 命令</td></tr><tr><td>git pack-objects</td><td>从标准输入读入对象ID，打包到文件</td></tr><tr><td>git pack-redundant</td><td>查找多余的 pack 文件</td></tr><tr><td>git pack-refs</td><td>将引用打包到 .git/packed-refs 文件中</td></tr><tr><td>git prune</td><td>从对象库删除过期对象</td></tr><tr><td>git prune-packed</td><td>将已经打包的松散对象删除</td></tr><tr><td>git relink</td><td>为本地版本库中相同的对象建立硬连接</td></tr><tr><td>git repack</td><td>将版本库未打包的松散对象打包</td></tr><tr><td>git show-index</td><td>读取包的索引文件，显示打包文件中的内容</td></tr><tr><td>git unpack-objects</td><td>从打包文件释放文件</td></tr><tr><td>git verify-pack</td><td>校验对象库打包文件</td></tr></tbody></table><h3 id="5、数据传输相关命令"><a href="#5、数据传输相关命令" class="headerlink" title="5、数据传输相关命令"></a>5、数据传输相关命令</h3><table><thead><tr><th><strong><em>\</em>命令**</strong></th><th><strong><em>\</em>简要说明**</strong></th></tr></thead><tbody><tr><td>git fetch-pack</td><td>执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象</td></tr><tr><td>git receive-pack</td><td>执行 git push 命令时在远程执行的命令，用于接受推送的数据</td></tr><tr><td>git send-pack</td><td>执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据</td></tr><tr><td>git upload-archive</td><td>执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档</td></tr><tr><td>git upload-pack</td><td>执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传</td></tr></tbody></table><h3 id="6、邮件相关命令"><a href="#6、邮件相关命令" class="headerlink" title="6、邮件相关命令"></a>6、邮件相关命令</h3><table><thead><tr><th><strong><em>\</em>命令**</strong></th><th><strong><em>\</em>简要说明**</strong></th></tr></thead><tbody><tr><td>git imap-send</td><td>将补丁通过 IMAP 发送</td></tr><tr><td>git mailinfo</td><td>从邮件导出提交说明和补丁</td></tr><tr><td>git mailsplit</td><td>将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件</td></tr><tr><td>git request-pull</td><td>创建包含提交间差异和执行PULL操作地址的信息</td></tr><tr><td>git send-email</td><td>发送邮件</td></tr></tbody></table><h3 id="7、协议相关命令"><a href="#7、协议相关命令" class="headerlink" title="7、协议相关命令"></a>7、协议相关命令</h3><table><thead><tr><th><strong><em>\</em>命令**</strong></th><th><strong><em>\</em>简要说明**</strong></th></tr></thead><tbody><tr><td>git daemon</td><td>实现Git协议</td></tr><tr><td>git http-backend</td><td>实现HTTP协议的CGI程序，支持智能HTTP协议</td></tr><tr><td>git instaweb</td><td>即时启动浏览器通过 gitweb 浏览当前版本库</td></tr><tr><td>git shell</td><td>受限制的shell，提供仅执行Git命令的SSH访问</td></tr><tr><td>git update-server-info</td><td>更新哑协议需要的辅助文件</td></tr><tr><td>git http-fetch</td><td>通过HTTP协议获取版本库</td></tr><tr><td>git http-push</td><td>通过HTTP/DAV协议推送</td></tr><tr><td>git remote-ext</td><td>由Git命令调用，通过外部命令提供扩展协议支持</td></tr><tr><td>git remote-fd</td><td>由Git命令调用，使用文件描述符作为协议接口</td></tr><tr><td>git remote-ftp</td><td>由Git命令调用，提供对FTP协议的支持</td></tr><tr><td>git remote-ftps</td><td>由Git命令调用，提供对FTPS协议的支持</td></tr><tr><td>git remote-http</td><td>由Git命令调用，提供对HTTP协议的支持</td></tr><tr><td>git remote-https</td><td>由Git命令调用，提供对HTTPS协议的支持</td></tr><tr><td>git remote-testgit</td><td>协议扩展示例脚本</td></tr></tbody></table><h3 id="8、版本库转换和交互相关命令"><a href="#8、版本库转换和交互相关命令" class="headerlink" title="8、版本库转换和交互相关命令"></a>8、版本库转换和交互相关命令</h3><table><thead><tr><th><strong><em>\</em>命令**</strong></th><th><strong><em>\</em>简要说明**</strong></th></tr></thead><tbody><tr><td>git archimport</td><td>导入Arch版本库到Git</td></tr><tr><td>git bundle</td><td>提交打包和解包，以便在不同版本库间传递</td></tr><tr><td>git cvsexportcommit</td><td>将Git的一个提交作为一个CVS检出</td></tr><tr><td>git cvsimport</td><td>导入CVS版本库到Git。或者使用 cvs2git</td></tr><tr><td>git cvsserver</td><td>Git的CVS协议模拟器，可供CVS命令访问Git版本库</td></tr><tr><td>git fast-export</td><td>将提交导出为 git-fast-import 格式</td></tr><tr><td>git fast-import</td><td>其他版本库迁移至Git的通用工具</td></tr><tr><td>git svn</td><td>Git 作为前端操作 Subversion</td></tr></tbody></table><h3 id="9、合并相关的辅助命令"><a href="#9、合并相关的辅助命令" class="headerlink" title="9、合并相关的辅助命令"></a>9、合并相关的辅助命令</h3><table><thead><tr><th><strong><em>\</em>命令**</strong></th><th><strong><em>\</em>简要说明**</strong></th></tr></thead><tbody><tr><td>git merge-base</td><td>供其他脚本调用，找到两个或多个提交最近的共同祖先</td></tr><tr><td>git merge-file</td><td>针对文件的两个不同版本执行三向文件合并</td></tr><tr><td>git merge-index</td><td>对index中的冲突文件调用指定的冲突解决工具</td></tr><tr><td>git merge-octopus</td><td>合并两个以上分支。参见 git merge 的octopus合并策略</td></tr><tr><td>git merge-one-file</td><td>由 git merge-index 调用的标准辅助程序</td></tr><tr><td>git merge-ours</td><td>合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略</td></tr><tr><td>git merge-recursive</td><td>针对两个分支的三向合并。参见 git merge 的recursive合并策略</td></tr><tr><td>git merge-resolve</td><td>针对两个分支的三向合并。参见 git merge 的resolve合并策略</td></tr><tr><td>git merge-subtree</td><td>子树合并。参见 git merge 的 subtree 合并策略</td></tr><tr><td>git merge-tree</td><td>显式三向合并结果，不改变暂存区</td></tr><tr><td>git fmt-merge-msg</td><td>供执行合并操作的脚本调用，用于创建一个合并提交说明</td></tr><tr><td>git rerere</td><td>重用所记录的冲突解决方案</td></tr></tbody></table><h3 id="10、-杂项"><a href="#10、-杂项" class="headerlink" title="10、 杂项"></a>10、 杂项</h3><table><thead><tr><th><strong><em>\</em>命令**</strong></th><th><strong><em>\</em>简要说明**</strong></th></tr></thead><tbody><tr><td>git bisect–helper</td><td>由 git bisect 命令调用，确认二分查找进度</td></tr><tr><td>git check-attr</td><td>显示某个文件是否设置了某个属性</td></tr><tr><td>git checkout-index</td><td>从暂存区拷贝文件至工作区</td></tr><tr><td>git cherry</td><td>查找没有合并到上游的提交</td></tr><tr><td>git diff-files</td><td>比较暂存区和工作区，相当于 git diff –raw</td></tr><tr><td>git diff-index</td><td>比较暂存区和版本库，相当于 git diff –cached –raw</td></tr><tr><td>git diff-tree</td><td>比较两个树对象，相当于 git diff –raw A B</td></tr><tr><td>git difftool–helper</td><td>由 git difftool 命令调用，默认要使用的差异比较工具</td></tr><tr><td>git get-tar-commit-id</td><td>从 git archive 创建的 tar 包中提取提交ID</td></tr><tr><td>git gui–askpass</td><td>命令 git gui 的获取用户口令输入界面</td></tr><tr><td>git notes</td><td>提交评论管理</td></tr><tr><td>git patch-id</td><td>补丁过滤行号和空白字符后生成补丁唯一ID</td></tr><tr><td>git quiltimport</td><td>将Quilt补丁列表应用到当前分支</td></tr><tr><td>git replace</td><td>提交替换</td></tr><tr><td>git shortlog</td><td>对 git log 的汇总输出，适合于产品发布说明</td></tr><tr><td>git stripspace</td><td>删除空行，供其他脚本调用</td></tr><tr><td>git submodule</td><td>子模组管理</td></tr><tr><td>git tar-tree</td><td>过时命令，请使用 git archive</td></tr><tr><td>git var</td><td>显示 Git 环境变量</td></tr><tr><td>git web–browse</td><td>启动浏览器以查看目录或文件</td></tr><tr><td>git whatchanged</td><td>显示提交历史及每次提交的改动</td></tr><tr><td>git-mergetool–lib</td><td>包含于其他脚本中，提供合并/差异比较工具的选择和执行</td></tr><tr><td>git-parse-remote</td><td>包含于其他脚本中，提供操作远程版本库的函数</td></tr><tr><td>git-sh-setup</td><td>包含于其他脚本中，提供 shell 编程的函数库</td></tr></tbody></table><h2 id="Git命令参考手册-文本版"><a href="#Git命令参考手册-文本版" class="headerlink" title="Git命令参考手册(文本版)"></a>Git命令参考手册(文本版)</h2><p>git init # 初始化本地git仓库（创建新仓库）<br>git config –global user.name “xxx” # 配置用户名<br>git config –global user.email “<a href="mailto:xxx@xxx.com" rel="external nofollow noreferrer">xxx@xxx.com</a>“ # 配置邮件<br>git config –global color.ui true # git status等命令自动着色<br>git config –global color.status auto<br>git config –global color.diff auto<br>git config –global color.branch auto<br>git config –global color.interactive auto<br>git clone git+ssh://git@192.168.53.168/VT.git # clone远程仓库<br>git status # 查看当前版本状态（是否修改）<br>git add xyz # 添加xyz文件至index<br>git add . # 增加当前子目录下所有更改过的文件至index<br>git commit -m ‘xxx’ # 提交<br>git commit –amend -m ‘xxx’ # 合并上一次提交（用于反复修改）<br>git commit -am ‘xxx’ # 将add和commit合为一步<br>git rm xxx # 删除index中的文件<br>git rm -r * # 递归删除<br>git log # 显示提交日志<br>git log -1 # 显示1行日志 -n为n行<br>git log -5<br>git log –stat # 显示提交日志及相关变动文件<br>git log -p -m<br>git show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容<br>git show dfb02 # 可只用commitid的前几位<br>git show HEAD # 显示HEAD提交日志<br>git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本<br>git tag # 显示已存在的tag<br>git tag -a v2.0 -m ‘xxx’ # 增加v2.0的tag<br>git show v2.0 # 显示v2.0的日志及详细内容<br>git log v2.0 # 显示v2.0的日志<br>git diff # 显示所有未添加至index的变更<br>git diff –cached # 显示所有已添加index但还未commit的变更<br>git diff HEAD^ # 比较与上一个版本的差异<br>git diff HEAD – ./lib # 比较与HEAD版本lib目录的差异<br>git diff origin/master..master # 比较远程分支master上有本地分支master上没有的<br>git diff origin/master..master –stat # 只显示差异的文件，不显示具体内容<br>git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）<br>git branch # 显示本地分支<br>git branch –contains 50089 # 显示包含提交50089的分支<br>git branch -a # 显示所有分支<br>git branch -r # 显示所有原创分支<br>git branch –merged # 显示所有已合并到当前分支的分支<br>git branch –no-merged # 显示所有未合并到当前分支的分支<br>git branch -m master master_copy # 本地分支改名<br>git checkout -b master_copy # 从当前分支创建新分支master_copy并检出<br>git checkout -b master master_copy # 上面的完整版<br>git checkout features/performance # 检出已存在的features/performance分支<br>git checkout –track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支<br>git checkout v2.0 # 检出版本v2.0<br>git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出<br>git checkout – README # 检出head版本的README文件（可用于修改错误回退）<br>git merge origin/master # 合并远程master分支至当前分支<br>git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改<br>git push origin master # 将当前分支push到远程master分支<br>git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支<br>git push –tags # 把所有tag推送到远程仓库<br>git fetch # 获取所有远程分支（不更新本地分支，另需merge）<br>git fetch –prune # 获取所有原创分支并清除服务器上已删掉的分支<br>git pull origin master # 获取远程分支master并merge到当前分支<br>git mv README README2 # 重命名文件README为README2<br>git reset –hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退）<br>git rebase<br>git branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）<br>git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933<br>git ls-files # 列出git index包含的文件<br>git show-branch # 图示当前分支历史<br>git show-branch –all # 图示所有分支历史<br>git whatchanged # 显示提交历史对应的文件修改<br>git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818<br>git ls-tree HEAD # 内部命令：显示某个git对象<br>git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASH<br>git reflog # 显示所有提交，包括孤立节点<br>git show HEAD@{5}<br>git show master@{yesterday} # 显示master分支昨天的状态<br>git log –pretty=format:’%h %s’ –graph # 图示提交日志<br>git show HEAD~3<br>git show -s –pretty=raw 2be7fcb476<br>git stash # 暂存当前修改，将所有至为HEAD状态<br>git stash list # 查看所有暂存<br>git stash show -p stash@{0} # 参考第一次暂存<br>git stash apply stash@{0} # 应用第一次暂存<br>git grep “delete from” # 文件中搜索文本“delete from”<br>git grep -e ‘#define’ –and -e SORT_DIRENT<br>git gc<br>git fsck</p><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><p>如果不想使用命令行，可以使用：<br>GitHub Desktop：<a href="https://desktop.github.com/" target="_blank" rel="noopener external nofollow noreferrer">desktop.github.com/</a> 只能提交github<br>tortoisegit：<a href="https://tortoisegit.org/" target="_blank" rel="noopener external nofollow noreferrer">tortoisegit.org/</a><br>SourceTree：<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener external nofollow noreferrer">www.sourcetreeapp.com/</a></p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora使用教程</title>
    <url>/2020/02/10/Typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info"><p>写Mrakdown费事？Typora让你像写Word一样行云流水，所见即所得。</p></div><img src="/2020/02/10/Typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/Typora.jpg" title="https://www.typora.io/"><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Typora是一款轻便简洁的Markdown编辑器，支持即时渲染技术，这也是与其他Markdown编辑器最显著的区别。即时渲染使得你写Markdown就想是写Word文档一样流畅自如，不像其他编辑器的有编辑栏和显示栏。</p><ul><li>Typora删除了预览窗口，以及所有其他不必要的干扰。取而代之的是实时预览。</li><li>Markdown的语法因不同的解析器或编辑器而异，Typora使用的是<a href="https://help.github.com/articles/basic-writing-and-formatting-syntax/" target="_blank" rel="noopener external nofollow noreferrer">GitHub Flavored Markdown</a>。</li></ul><h2 id="Markdown介绍"><a href="#Markdown介绍" class="headerlink" title="Markdown介绍"></a>Markdown介绍</h2><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。<br>Markdown 编写的文档后缀为 <code>.md</code>, <code>.markdown</code>。</p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul><li>加粗： <code>Ctrl + B</code></li><li>标题： <code>Ctrl + H</code></li><li>插入链接： <code>Ctrl + K</code></li><li>插入代码： <code>Ctrl + Shift + C</code> – 无法执行</li><li>行内代码： <code>Ctrl + Shift + K</code></li><li>插入图片： <code>Ctrl + Shift + I</code></li><li>无序列表：<code>Ctrl + Shift + L</code> – 无法执行</li><li>撤销： <code>Ctrl + Z</code></li><li>一级标题： <code>Ctrl + 1</code> – 以此类推<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Ctrl+1  一阶标题    Ctrl+B  字体加粗</span><br><span class="line">Ctrl+2  二阶标题    Ctrl+I  字体倾斜</span><br><span class="line">Ctrl+3  三阶标题    Ctrl+U  下划线</span><br><span class="line">Ctrl+4  四阶标题    Ctrl+Home   返回Typora顶部</span><br><span class="line">Ctrl+5  五阶标题    Ctrl+End    返回Typora底部</span><br><span class="line">Ctrl+6  六阶标题    Ctrl+T  创建表格</span><br><span class="line">Ctrl+L  选中某句话   Ctrl+K  创建超链接</span><br><span class="line">Ctrl+D  选中某个单词  Ctrl+F  搜索</span><br><span class="line">Ctrl+E  选中相同格式的文字   Ctrl+H  搜索并替换</span><br><span class="line">Alt+Shift+5 删除线 Ctrl+Shift+I    插入图片</span><br><span class="line">Ctrl+Shift+M    公式块 Ctrl+Shift+Q    引用</span><br><span class="line"></span><br><span class="line">注：一些实体符号需要在实体符号之前加”\”才能够显示</span><br></pre></td></tr></tbody></table></figure></li></ul><p>在markdown中，段落由多个空格分隔。在Typora中，只需回车即可创建新段落。</p><h3 id="标题级别"><a href="#标题级别" class="headerlink" title="标题级别"></a>标题级别</h3><p># 一级标题 快捷键为 Ctrl + 1<br>## 二级标题 快捷键为 Ctrl + 2<br>……<br>###### 六级标题 快捷键为 Ctrl + 6</p><h3 id="引用文字"><a href="#引用文字" class="headerlink" title="引用文字"></a>引用文字</h3><p>&gt; + 空格 + 引用文字</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用 * + - 都可以创建一个无序列表</p><ul><li>AAA</li><li>BBB</li><li>CCC<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3>使用 1. 2. 3. 创建有序列表</li></ul><ol><li>AAA</li><li>BBB</li><li>CCC<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3>-[ ] 不勾选<br>-[x] 勾选<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3>在Typora中插入程序代码的方式有两种：使用反引号 `（~ 键）、使用缩进（Tab）。</li></ol><ul><li>插入行内代码，即插入一个单词或者一句代码的情况，使用 <code>code</code> 这样的形式插入。</li><li>插入多行代码输入3个反引号（`） + 回车，并在后面选择一个语言名称即可实现语法高亮。<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helloworld</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello, world!"</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h3>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。根据需要加载 Mathjax 对数学公式进行渲染。<br>按下 <code>$$</code>，然后按下回车键，即可进行数学公式的编辑。<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf{V}<span class="emphasis">_1\times\mathbf{V}_</span>2 = \mathbf{X}_3</span><br><span class="line">$$</span><br></pre></td></tr></tbody></table></figure><h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3>输入 <code>| 表头1 | 表头2 |</code>并回车。即可创建一个包含2列表。快捷键 <code>Ctrl + T</code>弹出对话框。<table><thead><tr><th align="center">id</th><th align="center">name</th></tr></thead><tbody><tr><td align="center">No.1</td><td align="center">胡凯</td></tr></tbody></table></li><li>不管是哪种方式，第一行为表头，第二行为分割表头和主体部分，第三行开始每一行为一个表格行</li><li>列与列之间用管道符号<code>|</code> 隔开</li><li>还可设置对齐方式(表头与内容之间)，如果不使用对齐标记，内容默认左对齐，表头居中对齐<ul><li>左对齐 ：|</li><li>右对齐 |：</li><li>中对齐 ：|：</li></ul></li><li>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界</li><li>为了使 Markdown 更清晰，| 和 - 两侧需要至少有一个空格（最左侧和最右侧的 | 外就不需要了）。</li></ul><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>这个例子的脚注为<a href="https://www.cnblogs.com/hider/p/11614688.html#fn1" target="_blank" rel="noopener external nofollow noreferrer">1</a>。<br>注意：该例子脚注标识是1，脚注标识可以为字母数字下划线，但是暂不支持中文。脚注内容可为任意字符，包括中文。</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>输入 <code>***</code> 或者 <code>---</code> 再按回车即可绘制一条水平线，如下：</p><hr><h3 id="目录（TOC）"><a href="#目录（TOC）" class="headerlink" title="目录（TOC）"></a>目录（TOC）</h3><p>输入 <code>[ toc ]</code> 然后回车，即可创建一个“目录”。TOC从文档中提取所有标题，其内容将自动更新。</p><blockquote><p>Typora支持TOC自动生成目录，博客园不支持？</p></blockquote><h2 id="跨度元素"><a href="#跨度元素" class="headerlink" title="跨度元素"></a>跨度元素</h2><p>跨度元素即图片，网址，视频等，在Typora中输入后，会立即载入并呈现。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="内部链接"><a href="#内部链接" class="headerlink" title="内部链接"></a>内部链接</h4><p>这是一个带有标题属性的 <code>[链接](http://example.com/ "标题")</code><br>这是一个没有标题属性的 <code>[链接](http://example.net/)</code><br><a href="http://example.com/" target="_blank" rel="noopener external nofollow noreferrer">链接</a><br><a href="http://example.net/" target="_blank" rel="noopener external nofollow noreferrer">链接</a></p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>这是一个[参考链接]id – 无法执行</p><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><p>Typora允许用&lt;括号括起来&gt;, 把URL作为链接插入。<br>Typora还会自动链接标准网址。<br><a href="http://www.baidu.com" target="_blank" rel="noopener external nofollow noreferrer">www.baidu.com</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">![显示的文字](C:\Users\Hider\Desktop\echart.png "图片标题")</span><br><span class="line">![显示的文字](C:\Users\Hider\Desktop\echart.png)</span><br></pre></td></tr></tbody></table></figure><p>除了以上2种方式之外，还可以直接将图片拖拽进来，自动生成链接。</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><p>使用 <code>*单个星号*</code> 或者 <code>_单下划线_</code> 可以字体倾斜。快捷键 <code>Ctrl + I</code><br><em>斜体</em></p><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><p>使用 <code>**两个星号**</code> 或者 <code>__两个下划线__</code> 可以字体加粗。快捷键 <code>Ctrl + B</code><br><strong>加粗</strong></p><h3 id="加粗斜体"><a href="#加粗斜体" class="headerlink" title="加粗斜体"></a>加粗斜体</h3><p>使用<code>***加粗斜体***</code>可以加粗斜体。<br><strong><em>加粗斜体\</em></strong></p><h3 id="代码标记"><a href="#代码标记" class="headerlink" title="代码标记"></a>代码标记</h3><p>标记代码使用反引号，即在英文输入法下，ESC键下面和1键左边的符号。</p><blockquote><p>使用该 <code>printf()</code>功能</p></blockquote><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>使用<code>~~删除线~~</code> 快捷键 <code>Alt + Shift + 5</code><br><del>删除线</del></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>\下划线 – 无法执行<br>参考另一篇文章，可执行。<br>通过<code>下划线的内容</code> 或者 快捷键<code>Ctrl + U</code>可实现下划线<br>下划线的内容</p><h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><p>Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。<br>:smile – 无法显示<br>😺</p><h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>可以使用 <code>文本</code>实现下标。<br>(需在设置中打开该功能)<br>H<del>2</del>O<br>H2O</p><h3 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h3><p>可以使用<code>文本</code>实现上标。<br>(需在设置中打开该功能)<br>X^2^<br>X2</p><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><p><code>==高亮==</code>(需在设置中打开该功能)<br>==我是最重要的==</p><h3 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h3><p>使用 <code>这是要居中的内容</code>可以使文本居中<br>这是要居中的文本内容</p><h3 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h3><p>使用 <code>空格 + 空格 + Enter</code>可以实现换行，例如：<br>或者可以使用<code></code>实现换行。</p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：<br><strong>文本加粗</strong><br>** 正常显示星号 **<br>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">{}  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></tbody></table></figure><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>支持HTML<br>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。<br>目前支持的 HTML 元素有：<code></code>等 ，如：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</span><br><span class="line">&lt;kbd&gt; &lt;/kbd&gt; -- 白色框框</span><br></pre></td></tr></tbody></table></figure><p>效果：<br>使用 Ctrl+Alt+Del 重启电脑</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>建议打开大纲视图<code>Ctrl + Shift + 1</code></li><li>插入表格需要顶格写，否则无法显示</li><li>语法无须刻意记忆，右键可查询</li></ol><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>代码神器：拒绝重复编码，这款IDEA插件了解一下</title>
    <url>/2020/02/09/easycode/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Easycode是IDEA的一个插件，可以直接对数据的表生成entity、controller、service、dao、mapper无需任何编码，简单而强大。</p><h2 id="1、安装（Easy-Code"><a href="#1、安装（Easy-Code" class="headerlink" title="1、安装（Easy Code)"></a>1、安装（Easy Code)</h2><img src="/2020/02/09/easycode/Easy_Code.jpg" title="Install Easy_Code"><a id="more"></a><p>待装好之后，推荐大家可以安装一个插件，叫做Lombok。:your_emoji_1:</p><img src="/2020/02/09/easycode/Lombok.png" title="Install Lombook"><p>Lombok能通过注解的方式，在编译时自动为属性生成构造器、getter/setter、equals、hashcode、toString方法。出现的神奇就是在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。</p><h2 id="2、建立数据库"><a href="#2、建立数据库" class="headerlink" title="2、建立数据库"></a>2、建立数据库</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- ----------------------------</span><br><span class="line">-- Table structure for user</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `user`;</span><br><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `username` varchar(20) DEFAULT NULL,</span><br><span class="line">  `sex` varchar(6) DEFAULT NULL,</span><br><span class="line">  `birthday` date DEFAULT NULL,</span><br><span class="line">  `address` varchar(20) DEFAULT NULL,</span><br><span class="line">  `password` varchar(20) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></tbody></table></figure><img src="/2020/02/09/easycode/Mysql.png" title="Create Database"><h2 id="3、在IDEA配置连接数据库"><a href="#3、在IDEA配置连接数据库" class="headerlink" title="3、在IDEA配置连接数据库"></a>3、在IDEA配置连接数据库</h2><p>在这之前，新建一个Springboot项目，这个应该是比较简单的。</p><p>建好SpringBoot项目之后，如下图所示，找到这个Database</p><img src="/2020/02/09/easycode/Database.png" title="This is an example image"><p>​ 然后填写数据库名字，用户名，密码。点击OK即可。这样的话，<a href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;mid=2247490353&amp;idx=1&amp;sn=e385b6a0ae0b91fa6651cdb5ee6f5d96&amp;chksm=ebd6241ddca1ad0bd02022552a047244a37aab88c239e70a0b176b1214421033246532e07225&amp;scene=21#wechat_redirect" target="_blank" rel="noopener external nofollow noreferrer">IDEA连接数据库</a>就完事了。</p><p>​ 如果你在连接Mysql时，在地址，用户名，密码，数据库名，全配置好了，点击测试连接，咔！爆红！</p><img src="/2020/02/09/easycode/Localhost.png" title="Connection MySql"><p>这段错误信息翻译过来就是：服务器返回无效时区。进入“高级”选项卡，手动设置“serverTimezone”属性。</p><p>出现这个问题，一般原因在两个方面，第一，最基本的你Mysql驱动版本可能有问题，第二，设置mysql时区。</p><p>为什么时区会错误呢，那是因为Mysql默认的时区时UTC时区，比北京时间晚8个小时，所以我们要修改mysql的时长，首先我们先来检查下mysql的时区，前提是你安装mysql时配置好了系统环境变量。</p><p>如果你配置好了环境变量，那么就可以在命令窗口直接执行下面的命令啦！</p><p>1.进入命令窗口(Win+R),连接本地数据库 mysql -hlocalhost -uroot -p; ,回车，输入密码图：</p><p>2.继续输入 show variables like ‘%time_zone’;(注意不要漏掉后面的分号)，回车，如果现实 SYSTEM就是没有设置时区。</p><img src="/2020/02/09/easycode/CMD.png" title="Set the time zone"><p>3.现在我们来设置时区。</p><p>输入set globaltime_zone=‘+8:00’，回车，如图：</p><img src="/2020/02/09/easycode/Time_zone.png" title="Signs of success"><p>这便是设置成功啦！</p><p>这时你可以重新连接下数据库，如果成功，那么接着往下走！</p><img src="/2020/02/09/easycode/Test_Con.png" title="Reconnection"><h2 id="4-开始生成代码"><a href="#4-开始生成代码" class="headerlink" title="4.开始生成代码"></a>4.开始生成代码</h2><p>在这个你IDEA连接中找到你想生成的表，然后右键，就会出现如下所示的截图。</p><img src="/2020/02/09/easycode/Code.png" title="Reverse generated"><p>选择你要将生成的代码放入哪个文件夹中，选择完以后点击OK即可。</p><img src="/2020/02/09/easycode/Generate_Code.png" title="Select folder"><p>这样的话就完成了代码的生成了，生成的代码如下图所示：</p><img src="/2020/02/09/easycode/Coding.png" title="Select folder"><h2 id="5-pom-xml"><a href="#5-pom-xml" class="headerlink" title="5.pom.xml"></a>5.pom.xml</h2><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--热部署--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!-- 这个需要为 true 热部署才有效 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- mysql --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--阿里巴巴连接池--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="6-Application-yml"><a href="#6-Application-yml" class="headerlink" title="6.Application.yml"></a>6.Application.yml</h2><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8089</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/easycode?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*Dao.xml</span></span><br><span class="line">  <span class="attr">typeAliasesPackage:</span> <span class="string">com.easycode.demo.entity</span></span><br></pre></td></tr></tbody></table></figure><h2 id="7-启动项目"><a href="#7-启动项目" class="headerlink" title="7.启动项目"></a>7.启动项目</h2><p>在启动项目之前，我们需要修改两个地方。</p><p>在Dao层加上@Mapper注解</p><img src="/2020/02/09/easycode/Mapper.png" title="Mapper"><p>在启动类里面加上@MapperScan(“com.easycode.demo.dao”)</p><img src="/2020/02/09/easycode/Springboot.png" title="Springboot Runner"><p>启动项目 测试一下</p><p>EasyCode的用法就介绍到这里了，觉得有用的自己可以尝试一下~</p><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Easycode</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是推荐系统？</title>
    <url>/2020/01/29/%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%EF%BC%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>太长不读版：</strong>由推荐系统带来的推荐服务基本上已经渗透到我们生活的方方面面，本文作为浅谈推荐系统的基础篇，主要从下面几个维度介绍推荐系统的相关知识：</p><ul><li>什么是推荐系统</li><li>推荐系统在商业中的地位</li><li>推荐系统、搜索引擎及广告的关系</li><li>推荐系统的关键元素</li><li>推荐系统相关的算法</li></ul><a id="more"></a><p>篇幅较长，可能大部分道友比较关心算法部分，所以重点罗列了推荐系统算法思维演进史，每类算法理论点到即止，没有提供详细细节，但给出了相关阅读资料。全篇没有一个数学公式一行代码，初学者容易理解，有一定推荐系统相关知识的道友也可以起到一个系统化认识的作用。所属内容来自近期学习笔记，所提观点纯属抛砖引玉，如有疑问，欢迎大家积极讨论以及给出高见。</p><h2 id="什么是推荐系统"><a href="#什么是推荐系统" class="headerlink" title="什么是推荐系统"></a>什么是推荐系统</h2><p>按照维基百科的定义：推荐系统是一种信息过滤系统，用于预测用户对物品的评分或偏好。这个定义不是很好理解，因为它用“怎么做”来定义“是什么”，我们可以换个角度来理解：</p><ol><li>它能做什么？</li></ol><p>它可以把那些最终会在用户和物品之间产生的连接找出来。世间的万事万物都有连接，人与人之间的社会连接促进了社交产品的诞生，人与商品之间的消费连接造就了无数的电商产品，人和资讯越来越多的阅读连接促使了各类信息流产品的出现。</p><ol><li>它需要什么？</li></ol><p>推荐系统需要已经存在的连接，去预测未来的连接。比如电商平台会根据你买过什么，浏览过什么这些人和商品之间的连接来预测你还可能会买什么，又比如你在使用今日头条时每一次点击，每一次阅读都是连接，根据已有过去的点击、浏览行为来预测你感兴趣的内容。</p><ol><li>它是怎么做的呢？</li></ol><p>维基百科的定义已经解释了：预测用户评分和偏好，他们对应了推荐系统背后相关算法和技术的两大类别，还有更抽象的分类：机器推荐和人工推荐，也是我们常说的个性化推荐和编辑推荐。</p><ol><li>它解决的是什么问题？</li></ol><p>信息过载和长尾问题(长尾理论)。随着信息技术和互联网的发展，人们逐渐从信息匮乏的时代走入了信息过载的时代。消费者想从大量信息(物品)中找到自己感兴趣的信息，信息生产者想让自己生产的信息脱颖而出从而得到关注都是一件很难的问题，推荐系统的任务就是连接用户和信息(物品)。同时推荐系统要解决的另一个问题是需要发掘用户的行为，找到用户的个性化需求，从而将长尾商品准确的推荐给需要它的用户，同时帮助用户发现那些他们感兴趣但是很难发现的商品。</p><p>在信息过载的推动下，推荐系统成为了各大互联网公司攻城略地开疆拓土的必备良器。然而构建一个成熟的推荐系统并不是一件容易的事情，因为从技术上讲，它需要将数据、架构、算法、人机交互等环节有机的结合起来，需要用到数据挖掘技术、信息检索技术、计算统计学等悠久学科的相关知识。</p><h2 id="从商业角度看推荐系统"><a href="#从商业角度看推荐系统" class="headerlink" title="从商业角度看推荐系统"></a>从商业角度看推荐系统</h2><p>在商业社会中，有一种亘古不变的关系：供求关系，供求关系的背后是交换。无论是实体经济还是虚拟经济，都是基于这个原理。供求关系动态变化，当供给小于需求时，就产生了稀缺，有了稀缺，就有了商业。</p><p>推荐系统处理的是信息，它的主要作用是在信息生产方和信息消费方搭建起桥梁，从而建立连接。</p><p>在信息经济中，看上去供求方是信息生产者，需求方是注意力提供者(信息消费者)。推荐系统可以服务于不同类型的产品(资讯，社交，电商，游戏)，尽管它们最终得到真金白银的手段不一样，也就是所谓的商业模式各有不同，但是它们都有一个关键步骤就是：获得用户的注意力。</p><p>用户产生行为就是付出注意力的表现，比如信息流产品都是在看谁家的用户数多，阅读时间长，这些都是白花花的注意力。信息经济其实也就是注意力经济，而推荐系统就是留住注意力的重要手段之一。</p><p>那么注意力又是什么？它不是真的物理力，不属于四种宇宙基本力，而是一种决策可能性。比如用户为一个广告倾注了注意力，那么就有可能去点击广告，如果这个注意力非常强烈，还会继续消费广告中的商品，如果注意力足够持久，那么就会参与到整个商业链条上的各个经济活动。</p><p>但是注意力有个特点：总量有限。随着信息越来越丰富，注意力越来越稀缺。在门户时代的时候，信息稀缺，注意力丰富，是用户主动去寻找信息。到了搜索时代，虽然信息变得很丰富，但是在搜索引擎等工具的帮助下，这些信息并不会侵蚀用户的注意力，所以还是用户在主动寻找信息。但是在移动互联网普及之后，信息已经泛滥的非常严重，丰富的注意力被信息源以推荐的方式逐渐侵蚀，注意力从丰富变成稀缺。也是成了各大产商必争的生命源泉。</p><p>注意力本身有价值高低之分。资讯阅读类注意力量大，但是便宜，电商、游戏类注意力贵重，但数量上不如资讯阅读类。在某种程度上讲，行业里被粗略称呼的用户价值，实际上就是注意力价值。</p><p>在推荐系统的帮助下，注意力变成了稀缺方，信息源在打着灯笼到处寻找注意力，其实商品不再是信息，商品就是注意力，信息源变成了这些注意力的消费方。有限的注意力在推荐系统的帮助下，聚到了平台上，平台方需要像电力一样把这些注意力储存起来，储存起来的注意力就是平台方最有价值的资产。注意力的存在会导致平台上的内容被消耗，被消耗的内容又为平台带来收益，平台方通过经营平台内容维持注意力的体积从而达到商业运转的目的。</p><h2 id="推荐系统与搜索引擎及广告的关系"><a href="#推荐系统与搜索引擎及广告的关系" class="headerlink" title="推荐系统与搜索引擎及广告的关系"></a>推荐系统与搜索引擎及广告的关系</h2><p>在数字世界中，信息过载是必然的，应对信息过载的重担先后交给了搜索和推荐两兄弟。</p><p>要从浩航无边的知识海洋中获取想要的信息，针对“已知的未知”需求，首选的工具就是搜索引擎；而“未知的已知”和“未知的未知”则需要推荐系统去解决，介于两者之间，还有一种商业化解决信息触达问题方案，就是广告系统。从搜索广告到精准营销广告，逐渐形成了一个把广告当成一种有用的信息去找到最需要它的人的理念。</p><p>他们三者有共同之处，也有不同之处。搜索，推荐和广告本质上都在解决信息过载的问题，各自解决的手段、目标不相同，各自诞生在产品生命周期不同阶段，以至于系统实现也不尽相同。</p><p>搜索更关注内容消费者，搜索要解决的是精确快速找到想要的结果，最重要的目标是降低延迟和提高相关性。推荐系统不同于搜索引擎，用户使用搜索时目标明确，而使用推荐系统往往总会漫无目的。搜索和推荐都是为人找信息，而广告是为信息找人。</p><h2 id="推荐系统的关键元素"><a href="#推荐系统的关键元素" class="headerlink" title="推荐系统的关键元素"></a>推荐系统的关键元素</h2><p>大多数人在日常生活中，遇到推荐系统的高质量服务时，或者说被推荐的比较准确时，第一反应就是这个背后使用的什么样的算法，认为算法是推荐系统最核心的东西，只有最牛的算法才知道我现在在想什么我需要什么。但是算法只是关键元素之一，而且占的分量不大，关键元素有：</p><ul><li>UI和UE</li><li>数据</li><li>领域知识</li><li>算法</li></ul><p>他们的权重大致为40%，30%，20%，10%。在这个看脸就成功了一半的时代，如果要构建一个成熟复杂的推荐系统，最新优化的一定是产品的UI和UE。用户对产品的体验，视觉是否符合目标用户的审美，交互逻辑是否简单明了，这些因素都会决定用户是否会持续使用产品。只有用户留下来了，才有推荐系统的用武之地。</p><p>数据和UI、UE同等重要，是推荐系统的基石。强大的推荐系统如果给用户的第一感觉不是使用了什么样的算法，那么就要是我在什么时候暴露了什么数据。前面已经提到了推荐系统就是要从已有的数据中找到存在的连接，再预测可能存在的连接。如果没有充足的数据，那么预测结果的可靠性也就可想而知了。</p><p>每一个产品存在于市场上，总有一部分价值是大多数其他产品无法替代的，这部分价值就涉及到了领域知识，比如电商产品有自己的领域知识：普通用户更在意的价格而不是兴趣。音乐产品也就自己的领域知识，比如不要向一个歌手的死忠粉推荐这个歌手的任何一首歌曲，因为作为死忠粉，每一首歌曲他都听过了。但是部分电商产品不一样，买过的商品还有可能再买的情况。</p><p>随着信息技术和互联网的发展，用于推荐系统的相关算法也在不断的发生更替，但是时至今日，也没有说哪一种算法非常厉害能解决所有问题，每个算法都有最适合自己的特殊场景，所以成熟的推荐系统并不会仅仅依赖于一两种特定的算法，而是对多种基础算法进行融合，集百家之所长。</p><h2 id="推荐系统相关的算法"><a href="#推荐系统相关的算法" class="headerlink" title="推荐系统相关的算法"></a>推荐系统相关的算法</h2><p>对于技术人员来讲，或许算法才是大家最感兴趣的部分，但是这里只是简要的概括推荐系统相关算法体系，不会具体到算法细节，因为任何一种算法的细节都可以讲上一天半载。</p><p>总的来说常见的推荐系统算法体系可以分为这几类：内容推荐、协同过滤推荐、矩阵分解、模型融合。</p><h3 id="1-内容推荐"><a href="#1-内容推荐" class="headerlink" title="1. 内容推荐"></a>1. 内容推荐</h3><p>内容推荐是推荐系统的孩童时代，但是在今天它依然适用于各个领域。内容推荐有其内容数据比较好获取的优点，在从零开始构建一个推荐系统时起到了非常重要的作用。基于内容的推荐要做到四步：抓取数据、清洗数据、挖掘数据、应用算法。</p><p>1.1 抓取数据</p><p>数据是整个推荐系统的源泉，所以即使是在用户越来越注重数据隐私的今天，哪怕是上千亿的大厂，都有自己的数据爬取团队不断地从外部和内部抓取数据，他们整天在爬取和反爬取中斗法，就为了多获取或者少流失一点数据，只有当内容具有了多样性，一个推荐系统才有存在的合法性。</p><p>1.2 清洗数据</p><p>无论是抓来的数据还是自己生产的数据都需要经过清洗，毕竟大家都是借鉴来借鉴去，存在重复的内容是很正常的事情，所以需要去重，在去重的同时，还需要识别垃圾内容、色情内容、政治敏感内容。</p><p>1.3 挖掘数据</p><p>基于内容的推荐，最重要的不是推荐算法，而是内容挖掘和分析，内容数据尤其是文本数据，只要深入挖掘，就可以挖掘出一些信息供推荐系统使用。内容分析的越深入，能抓住的用户群体就越细致，推荐的转化率就越高。</p><p>内容分析的结果主要有两类：一个是用户画像和物品画像的结构化内容库，另一个是分析过程中可能得到的模型，如主题模型、分类器模型、实体识别模型、嵌入模型等，这些模型主要用于实时推荐刚刚加入的新物品，通过对物品内容的实时分析，提取结构化内容，再用于用户画像匹配。</p><p>内容挖掘主要会用到自然语言处理(NLP)相关技术，如：</p><ul><li>使用IF-IDF和TextRank进行关键词提取；</li><li>使用隐式马尔科夫模型(HMM)或者条件随机场(CRF)进行实体识别(序列标注)；</li><li>在有分类体系的前提下使用SVM或FastText工具对文本进行分类；</li><li>使用LDA等无监督算法对文本聚类或从文本中抽取主题模型；</li><li>使用Word2Vec、Embedding的方式挖掘出字面意思下的语义信息。</li><li>同时可以使用卡法检测(CHI)和信息增益(IG)等方法从众多标签中选出主要的标签。</li></ul><p>1.4 相似度计算</p><p>基于内容的推荐，最简单的算法就是计算相似性，可以把用户画像和物品画像表示成稀疏的向量，两者之间计算余弦相似度，根据相似度对推荐物品排序，也可以使用信息检索中的相关性计算方法如BM2F算法来做推荐匹配计算。同时在传统机器学习方面，可以结合逻辑回归(Logistic Regression)和梯度提升树(GBDT)训练一个二分类模型，把用户、物品的结构化内容，日志记录的上下文信息(如时间、地点、设备)作为特征，从而预测用户“喜欢”和“不喜欢”的用户行为。随着近几年深度学习的大火大热，同样可以根据用户、物品画像以及上下文信息训练一个类似Deep &amp; Wide的端到端的神经网络预测模型。</p><h3 id="2-协同过滤推荐"><a href="#2-协同过滤推荐" class="headerlink" title="2. 协同过滤推荐"></a>2. 协同过滤推荐</h3><p>当推荐系统度过了只能使用基于内容的推荐结果后，就已经积累的一定的用户行为了，这些行为通常是正向的，也就是或明或暗的表达着用户喜欢的行为。这些行为可以表示成用户和物品的关系矩阵，而近邻推荐主要基于这个关系矩阵来计算用户之间、物品之间的相似度从而达到推荐的目的。</p><p>协同过滤是推荐系统算法里面最著名的算法，协同过滤通常分为两类：基于记忆的协同过滤(Memory-Based)和基于模型的协同过滤(Model-Based)，基于记忆的协同过滤又可以分为基于用户的协同过滤(User-Based)和基于物品的协同过滤(Item-Based)</p><p>2.1 原理</p><p>基于用户的协同过滤就是根据历史用户行为，通过计算用户相似度的方式，找到和目标用户的相似用户群体，然后将相似用户群体消费过的、喜欢的物品推荐给目标用户。</p><p>基于物品的协同过滤也是根据历史用户行为，不过计算的是物品之间的相似度，先找到一批和用户消费过的物品的相似物品，然将这些相似物品推荐给用户。</p><p>相对于基于用户的协同过滤，基于物品的协同过滤在物品数远远小于用户数的时候比较适用，同时物品之间的相似度比较静态，它们的变化速度远远没有用户口味变化快。</p><p>2.2 存储</p><p>在实践过程中，我们往往会先构建用户和物品的关系矩阵，然而这个矩阵是非常稀疏的，所以在大数据量存储的时候可以选择典型的稀疏矩阵存储方式CSR或者COO。</p><p>2.3 改进</p><p>协同过滤可能会带来马太效应，所以会有一些常见的改进方法。</p><p>基于用户的协同过滤主要改进在用户对物品的喜好程度上，比如惩罚对热门物品的喜好程度，增加喜好程度的时间衰减等方法；</p><p>基于物品的改进主要有物品中心化和用户中心化，即先分别减去物品、用户分数的均值，再进行相似度计算。</p><p>2.4 输出</p><p>协同过滤推荐有两类输出：相似用户、物品列表，基于用户、物品的推荐结果。</p><p>推荐结果也有两种表现形式：第一种是TopK推荐，形式上有点类似“猜你喜欢”，也就是先降序排序用户对物品加权求和后的预测评分，然后选取前K个物品推荐给用户；另外一种是相关推荐，也就是我们经常看到的“看了又看”，“买了又买”的推荐结果。</p><p>2.5 相似度计算</p><p>相似度计算是协同过滤算法的核心部分，针对不同问题会选择不同的相似度计算方式，常用到的计算方式有：</p><ul><li>适用于分析用户能力模型之间差异的欧式距离；</li><li>在文本、物品、用户相似度计算比较常用的余弦相似度；</li><li>同时针对余弦相似度对绝对值大小不敏感的问题，还有调整的余弦相似度(Adjusted Cosine Similarity)，也就是先计算向量每个维度的均值，然后每个向量在每个维度上减去均值，再计算余弦相似度;</li><li>度量两个随机变量是不是同时增减的皮尔逊相关度(Pearson)；</li><li>适合于布尔值的杰拉德相似度(Jeccard);</li></ul><p>2.6 Slope One算法</p><p>经典的协同过滤算法，相似度矩阵无法实时更新，整个过程都是离线计算的，同时相似度计算没有考虑相似的置信问题，比如两个物品有且仅被一个用户喜欢了，余弦相似度的结果为1，然而这两个物品可能并不相似。所以有针对此类问题的改进算法，如的Slope One算法等，但是Slope One算法只适用于评分问题。</p><h3 id="3-矩阵分解"><a href="#3-矩阵分解" class="headerlink" title="3. 矩阵分解"></a>3. 矩阵分解</h3><p>推荐系统的经典问题中有一类是评分问题，这类问题只是很典型，但不是很大众，主要原因是评分数据很难收集，与此相对的行为预测问题会更普及一些。</p><p>矩阵分解的盛行得益于多年前Netflix Prize那份关于评分预测比赛一百多万美元的奖赏。话说2006年10月2号那天，影视界的土财主Netflix广发英雄帖召集四海八荒各路豪杰，在已有推荐系统的基础上降低电影评分预测的均方根误差，只要误差降低了10%的大侠，就可以瓜分100万美刀，消息一出，群贤毕至。评分预测问题在一百万美刀的加持上，催生出了无数的推荐算法，最为著名的就是矩阵分解系列算法，其中最著名的是SVD及各种变体。</p><p>3.1 SVD</p><p>在矩阵分解算法出现之前，推荐领域的算法主要还是以近邻推荐为主，但是近邻推荐有几个问题：一是物品之间的相关性，信息量不会随着物品向量的维度而线性增加，二是关系矩阵元素稀疏，增加和减少一个向量维度，导致结果的差异性很大。横空出世的矩阵分解可以解决上面的问题，直观上来讲，就是把原来一个很大的关系矩阵，近似的分解为两个分别代表用户和物品矩阵的乘积，推荐的时候不再使用大的矩阵，而直接使用分解之后的小矩阵。一个矩阵由代表用户偏好的用户隐因子向量组成，另一个矩阵由代表物品语义主题的隐因子向量组成，矩阵的奇异值分解(SVD)就是最基本的分解算法之一。</p><p>3.2 增加偏置信息</p><p>基础的SVD没有考虑用户和物品的偏置信息，会使得在一些现实情景下整个平台的评分会很高。比如标准宽松的用户常常会给出偏高的分值，同时一些电影的铁粉也会对追随的电影，无论质量高低，都打较高的分值。所以在基础的SVD基础上，出现了第一个变种：将用户、物品偏置信息抽出来的SVD，和基本的SVD相比，它要多学习两个参数：用户偏置和物品偏置。</p><p>3.3 增加隐式信息和用户属性</p><p>在增加完偏置之后，还有另外一个问题需要解决：有的用户评分少，也就是显示反馈比隐式反馈少(通俗来讲，显式反馈是指能明确表达用户喜好的反馈行为，如评分，评分越高表示用户越喜欢；相反隐式反馈指不能直接表达用户是否喜欢的行为，如点击、阅读，用户点击或者阅读了一个物品，并不能表示用户喜欢这个物品，有可能就是简单的看了一下发现不敢兴趣就离开了，所有我们常常要从其它维度来判断用户是否喜欢这个物品，比如点击的次数、阅读的时长等)。所以后来的SVD++在前面的基础上增加了隐式反馈和用户属性等基本信息，在学习的过程中又多了两个向量：隐式反馈的物品向量，用户属性的特征向量。</p><p>3.4 增加时间因素</p><p>解决完上面的问题之后，又正视了另外一个问题：人是善变的，一年前的我们和现在我们的偏好可能发生了翻天覆地的变化，那么在SVD中考虑时间因素也变得顺理成章了。在SVD中考虑时间因素主要有这几种做法：对评分按时间加权；对评分按时间段划分区间，不用时间区间分别学习对应的隐因子；对特殊的期间如节假日等训练对应的隐因子。</p><p>3.5 ALS</p><p>矩阵分解除了上面提到的SVD系列算法之外，还有一种的比较流行的算法：交替最小二乘(ALS)，他们的区别是SVD在优化过程中主要使用随机梯度下降(SGD),而交替最小二乘则是利用矩阵的逆矩阵计算方式不断优化目标，交替最小二乘的一个好处是可以参数并行化，而且在不是很稀疏的数据集上，会比随机梯度下降要更快的得到结果。</p><p>3.6 WeightedALS</p><p>矩阵分解算法是为解决评分问题而生的，而实际上推荐系统更关注的是预测行为，也就是一再强调的隐式反馈。可以使用One-Class的思维将预测评分问题转换成预测行为问题，相对应的有改进后的加权交替最小二乘(WeightedALS)，专门解决隐式问题的矩阵分解。</p><p>3.7 贝叶斯个性化排序</p><p>矩阵分解在推荐系统的地位很高，因为它既有协同过滤的血统，又有机器学习的基因。但是由于它的目标优化函数的定义，它提倡的方法还是让人颇有微词。因为目标是使矩阵分解结果的乘积尽量接近原始矩阵，但是在实际使用的过程中，却是拿这两个矩阵乘积的预测结果来排序。这种针对单个物品的偏好程度进行预测，得到结果后再排序的问题，在排序学习中称为point-wise，与之相对的，有直接预测物品两两之间相对顺序的问题，叫pair-wise。所以贝叶斯学派提出的贝叶斯个性化排序(简称BPR模型)直接预测物品的相对顺序，而非精确的评分。</p><h3 id="4-模型融合"><a href="#4-模型融合" class="headerlink" title="4. 模型融合"></a>4. 模型融合</h3><p>推荐系统在技术实现上一般分为三个阶段：挖掘、召回、排序。</p><p>挖掘的工作就是对用户和物品做非常深入的结构化分析，各角度各层面的特征都被呈现出来，并建立好索引，供召回阶段使用，大部分挖掘工作都是离线进行的。</p><p>那么召回又是什么呢？因为物品数目太多，每次给用户计算推荐结果的时候，如果对全部物品依次计算将会是一个灾难，取而代之的就是利用各种简单的、复杂的推荐算法从全量的物品中先筛选一部分比较靠谱的。</p><p>最后的排序就是对筛选出来的靠谱结果做一个统一的排序，这个排序过程就会涉及到各模型结果的融合。不同的算法只负责推举出候选结果，真正的是否推荐给用户，由另外一个模型说了算，这个就叫做模型的融合。</p><p>4.1 模型融合</p><p>在推荐系统模型融合阶段，要以产品的目标为导向，比如在信息流推荐中，如果要以提高CTR为目标，那么就可以在推荐一个物品之前，使用逻辑回归预估用户对它的点击率有多大，再根据这个点击率对物品的输出排序。逻辑回归主要的两个任务就是组合特征、学习权重。</p><p>特征组合有一个难点就是组合数目非常庞大，而且不是所有组合都有效，只有少数组合有效。权重的学习主要看两个方面：一个是损失函数的最小化，也就是模型的偏差是否足够小；另一个是模型的正则化，也就是模型的方差是否足够小。偏差代表着模型在训练集上的准确性，偏差越小，预测值和真实值也就接近；方差代表着模型的稳定性和泛化能力，方差越小，模型越稳定，泛化能力越好，越能在真实环境适用。偏差和方差的权衡一直是机器学习领域老生常谈的话题。</p><p>此外逻辑回归使用随机梯度下降法优化损失函数，随机梯度下降常常被人诟病的是它很难得到稀疏的模型，效果收敛也很慢。幸运的是Google在2013年KDD上发表了一种新的结合了L1正则和L2正则的在线优化算法：FTRL，被广大厂家应用在自己的在线训练平台中。</p><p>4.2 逻辑回归和梯度决策树</p><p>在逻辑回归中，特征组合能有效表达出数据中的非线性事实，但是发现成本很高，需要花大量的人力和物力，而我们之前提到的梯度提升决策树(GBDT)可以解决这个问题。梯度提升决策树分为两个部分：沿着残差梯度下降的方向构建子模型的集成模型方案(GB)和构建子模型时用到的决策树(DT)。在定义损失函数时，把逻辑回归中的误差平方和换成适合分类的损失函数，例如对数损失函数。业界往往在模型融合的时候把逻辑回归和梯度决策树结合起来使用，GBDT的任务就是产生高阶特征组合，从而取代逻辑回归中的手工组合特征的工作。</p><p>4.3 因子分解机模型</p><p>前面提到特征组合是一个很庞大的工程，在组合二阶特征时，两两组合会导致特征灾难，同时大多数特征组合都不会产生效果，由于对应样本的限制，没办法学习到对应组合特征的权重，所有只能放弃。而另一类算法模型能够解决这个问题：因子分解机模型(FM, Factorization Machine)。FM也常被拿来做模型融合。FM模型最直接的观点就是每一个特征学习一个隐因子向量，在特征组合的时候将两两特征的隐因子向量做一个向量内积，作为两者组合的权重，取代了前面去学习组合特征后的权重的方法。一定程度上讲，前面提到的SVD系列的矩阵分解法只是FM中的特例，在特定条件下，可以使用FM推导出SVD系列的算法。</p><p>4.4 Field-aware Factorization Machine</p><p>在特征数目比较多时，有时候对两个特征的隐因子做内积计算也是一件比较耗费时间的事情，那么我们可以通过先对特征聚类的方法将特征聚类成几个类簇，每个类簇有自己的隐因子向量，在内积计算的时候，只需要选取当前特征和对应特征所在类簇进行内积就行了，使用这种方法可以大大的减轻计算量。这种改进被称为Field-aware Factorization Machine，简称FFM。</p><p>4.5 Deep &amp; Wide</p><p>类似逻辑回归这样的广义线性模型主要采用特征海洋战术来做模型融合，不断的挖掘新特征、挖掘特征组合模型、寻找新的离散特征分散方法。这种单模型加特征的方式有很多好处：模型简单，训练和预测计算复杂度相对低；工程师们挖掘特征工程可以并行化；线性模型的可解释性相对非线性模型好。</p><p>特征工程让线性模型表现为一个比较宽的模型，能在训练集上得到不错的性能，但是泛化能力稍有欠缺。在深度学习大行其道的今天，深度学习的泛化能力强于线性模型。所以前面提到的Deep &amp; Wide模型结合两者的优点，将宽度和深度模型结合起来进行模型融合。宽度模型就是我们前面提到的广义线性回归模型，如Logistic Regression等，而深度模型指的的多层的前馈神经网络。</p><p>深度模型对原始的高维稀疏类别型特征，先进行嵌入学习，转换为稠密、低维的实值型向量，转换后的向量维度通常在10-100这个范围。这里的嵌入学习，就是先随机初始化嵌入向量，再直接扔到整个前馈网络中，用目标函数来优化学习。最后在融合的时候，由逻辑回归作为最终输出单元，深模型最后一个隐藏层作为特征接入逻辑回归，宽模型的原始特征与之一起接入逻辑回归，然后端到端的训练参数。</p><p>4.6 MAB</p><p>前面提到了融合阶段会基于召回阶段各推荐算法产生的推荐结果进行排序，从另外一个角度来看，这其实是一个选择哪个算法输出的结果作为最终结果的问题，针对不同的业务场景，制定不一样的融合策略。选择问题往往是现实生活中最头疼的问题之一，而Bandit算法就是为选择而生。</p><p>Bandit算法来源于人们喜闻乐见的赌博学，它描述的是一个赌徒去赌场摇老<em>虎</em>机的故事，不同的老<em>虎</em>机外表一模一样，但是吐钱的概率不一样，在不知道每台老<em>虎</em>机吐钱的概率分布分别是什么的情况下，怎么最大化收益。这个问题又被称为多臂赌博机问题(Multi-armed bandit problem, K-armed bandit problem, MAB)简称MAB问题。只要是关于选择的问题，都可以简化成MAB问题。</p><p>推荐系统里面有两个顽疾，一个是冷启动，另一个是探索利用问题，后者又称为Exploit-Explore问题。Bandit算法都可以对着两个问题对阵下药。冷启动问题是指针对于新加入的用户、物品或者推荐系统刚启动时，没有足够的历史数据，就无法进行准确的预测。而Exploit-Explore问题描述的是两个方向的权衡问题，以用户的兴趣为例，利用(Exploit)指的是要充分利用我们挖掘到的用户的兴趣，而探索(Explore)指的是用户的兴趣会随时间发生变化，在利用的同时，我们应该继续探索挖掘新的用户兴趣，不要故步自封，坐吃山空。</p><p>另外需要指出的是Bandit 算法并不是指一个算法，而是一类算法。Bandit算法的思想是：看看选择会带来多少遗憾，遗憾越少越好。在 MAB问题里，用来量化选择好坏的指标就是累计遗憾。常见的Bandit算法有：汤普森采样算法、UCB(Upper Confidence Bound)算法、Epsilon贪婪算法。</p><p>基本的Bandit算法没有使用候选臂的特征信息，特征是机器学习的核心要素，是机器学习泛化的依赖元素，于是乎Yahoo的科学家们在2010年基于UCB提出了LinUCB算法，和传统的UCB相比，最大的改进就是加入了特征信息。</p><p>前面提到了协同过滤是推荐系统里面最经典的算法，因为它利用的全体的智慧，但是它无法捕捉到用户的兴趣变化，而且容易造成马太效应，也就是典型的Exploit过了头，而Bandit提倡走一步看一步，不断Explore行的东西，将两者结合起来，就有了COFIBA算法。</p><h3 id="5-其它算法"><a href="#5-其它算法" class="headerlink" title="5. 其它算法"></a>5. 其它算法</h3><p>5.1 排行榜算法(热门推荐算法)</p><p>前面已经提到了推荐系统有一个顽疾，冷启动，一个新用户来了，推荐系统对他一无所知，这个时候可以尝试给他推荐最热门的东西，等积累一定的数据之后，再选择其它的个性化推荐方案。然而排行榜算法不仅仅是计算卖的最好的或者阅读量最多那么简单。最简单的排行榜，就是直接统计某种指标，按照大小去排序。在社交网站上，按照点赞数、转发数、评论数去排序，这是一种最常见、最朴素的排行榜。这些做法不是很靠谱，因为很容易被攻击，也就是被刷榜；并且马太效应一致存在，除非强制替换，否则榜上永远都是那些信息；同时这样的计算不能反应排行榜随时间的变化。所以在算法设计的时候，需要考虑到时间因素，可以用热力学定律来定义每个物品，即排行榜里的每个物品都是炙手可热具有一定温度的，随着时间的推移一定会耗散到周围，温度就会下降。</p><p>5.2 用户标签的加权采样</p><p>在数据挖掘完成后，我们一般会为用户计算兴趣标签，如果计算的标签太多的话，每次召回候选集的时候，计算的复杂度会很大，如果能给每个标签设定对应的权重，这个时候可以使用简单的加权采样法，每次召回的时候不使用全部的用户标签，而是按照权重采样一部分标签来使用，这样做有很多好处：减少了计算复杂度；可以保留更多的标签；每次召回计算时还能有所变化，添加了随机性，有利于模型泛化。</p><p>加权采样有两种方式，一是知道全部样本个数，每次采样时遍历所有的标签，来依次决定每个标签输出的概率；另外一种就是不知道数据集有多大，获取的数据是数据流，对应的就是流采样，又叫蓄水池采样，就是可以在模型融合之后加一层蓄水池抽样，或者在召回阶段加一层蓄水池采样，这样在不影响整个推荐流程和转化概率的前提下，降低计算复杂度，提升推荐多样性。</p><p>同时在线阶段要使用用户的反馈行为做实时推荐，对于不同的用户，活跃程度不同，产生的反馈行为数量不同，也可以用蓄水池采样，为每个用户取出固定数量的行为用于更新推荐结果。蓄水池采样的做法是假设一批数据有n个，先直接获取K个样本保留，然后从K+1个样本起，每个样本以k/n的概率替换保留的K个样本中的一个。</p><p>5.3 去重算法</p><p>在推荐系统中，去重是刚需，主要用在两个地方：一是内容源去重，二是不重复给用户推荐。前面已经提到由于“相互借鉴”的原因，我们获取的数据很大程度上存在重复值，所以需要对内容做重复性检测。直观的思路是分词，然后提取关键词，再两两计算词向量之间的距离，距离小于一定阈值后就判定为重复。但是对应海量的内容，两两比较简直是一个灾难。内容去重在搜索引擎时代就已经是一个刚需了，所以可以复用搜索引擎的做法，Google在2007年的时候公开了他们的内容重复检测算法Simhash，这个算法简单有效，甚至造就了今天的信息流推荐产品。</p><p>Simhash核心思想也是为每个内容生成一个整数来表示指纹，然后用这个指纹去做重复或者相似的检测。当然这个指纹肯定不像MD5那样的指纹计算那么简单，常常会用Jenkins算法把每个词哈希成一个多位二进制的整数，然后不同词之间再做加减运算获得内容的指纹，获取到内容的指纹之后，可以两两计算汉明距离，比较二进制位不同个数，然后再和阈值比较得到是否相同的结论。</p><p>除了内容重复检测，还有一个需求是防止已经推荐的内容被重复推荐。和上述内容去重相比，最大的不同是过滤对象不同，Simhash过滤的是内容本身，而这里一般指的是内容的ID，在数据量不是太多的情况下，可以为每个内容建立一个UUID，然后用专门的数据库来保存，还可以为它建上索引来保证查询时的高效性。但是数据巨大时，对于存储的消耗又是一个问题，有一个比较老但是比较有用的做法是布隆过滤器Bloomfilter，布隆过滤器的原理也要用到哈希函数。它包含两部分：一个很长的二进制位向量，和一系列哈希函数。Bloomfilter 也并不是百分之百保证的，有很小的概率把原本不存在集合中的模式串判断为存在，但是这个小概率是可以承受的。</p><p>5.4 深度学习算法：</p><p>近几年，深度学习的圣火燎原般地燃烧到各个领域，推荐也不例外，大厂商们不断地在将神经网络融入到推荐服务的路上上下而求索。</p><p>携程不断演进的AutoEncode系列算法，将用户和物品关系矩阵中每一行或者每一列作为网络的输入和输出，训练用户和物品的编码器，同时在后续的改进版本中把噪声、用户属性、物品属性信息作为side information以及上下文情景融入到网络中提升模型的性能。</p><p>电商巨擘阿里提出了最大堆树模型TDM(Tree-based Deep Match)，它将树结构和神经网络结合起来的，在超大数据量下，通过对用户兴趣进行层次切分和逐层圈选，避免了直接在全量候选集上的超大计算，它采用将大问题切割成多个小问题递归求解的方式实现全库检索，从而提升结果的新颖比例并保持了召回效果。同时在广告领域，借助类似注意力(Attention)模型新增网络结构DIN(Deep Interest Network)，对用户的历史数据和待估算的物品进行部分匹配、计算权重(匹配度越高的历史数据就对结果的影响越大)。</p><p>社交网络广告领域，领英提出的Audience Expansion for Online Social Network Advertising尝试解决如何定位目标受众和原始受众的相似属性的问题。</p><p>除此此外，还有些其它的网络结构，Node2Vec，Wide &amp; Deep，Deep Neural Networks for YouTube Recommendations，Convolutional Matrix Factorization for Document Context-Aware Recommendation。</p><p>除了各大厂商的研究以外，学术界也研究了各种网络结构，如PNN(Product-based Neural Network), NFM(Neural Factorization Machine), AFM(Attention Factorization Macine), NCF(Neural Collaborative filtering)。具体细节代码可参考 Github代码</p><p>5.4 强化学习算法：</p><p>把推荐系统当成Agent，获取用户信息和上下文信息(state)，将物品推荐(action)给用户，用户及时做出反馈(reward)，Agent评估Exploitation Network Q和Exploration Network Q~ 的表现，如果Q效果更好，即推荐的准确，得到了正向的reward，那么保持模型不变，如果 Q~ 的表现更好，则将Q的参数向Q~变化，一段时间后，再根据积累的历史经验对Q模型参数进行更新，这就是DQN在推荐领域的案例。通过这样的方式，将强化学习应用到推荐领域。强化学习特别适合于需要及时捕捉到动态变化的情景。国内大厂阿里京东在这方面颇有建树，详情请参照论文：Deep Reinforcement Learning for List-wise Recommendations, DRN:A Deep reinforcement Learning Framework for News Recommendation。</p><p>算法部分就介绍到这里，所涉及到的理念都是一些比较浅显的概念，而且所列举的算法都是算法簇里面的冰山一角，如果想要了解更多的话，还得继续往后面深挖才行，当然那也不是基础篇的内容了。</p><p>下面是一些参考资料，有兴趣的话可以了解一下，欢迎补充。</p><ul><li>内容推荐<ul><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//www.aclweb.org/anthology/E/E17/E17-2068.pdf" target="_blank" rel="noopener external nofollow noreferrer">Bag of Tricks for Efficient Text Classification</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//research.google.com/pubs/archive/36955.pdf" target="_blank" rel="noopener external nofollow noreferrer">The Learning Behind Gmail Priority Inbox</a></li><li>书籍: Recommender Systems Handbook(Chapter3,9)</li></ul></li><li>协同过滤<ul><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//www.cs.umd.edu/~samir/498/Amazon-Recommendations.pdf" target="_blank" rel="noopener external nofollow noreferrer">Amazon.com recommendations: item-to-item collaborative filtering</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//arxiv.org/pdf/cs/0702144.pdf" target="_blank" rel="noopener external nofollow noreferrer">Slope One Predictors for Online Rating-Based Collaborative Filtering</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!http%3A//files.grouplens.org/papers/www10_sarwar.pdf" target="_blank" rel="noopener external nofollow noreferrer">Item-Based Collaborative Filtering Recommendation Algorithms</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//drive.google.com/drive/folders/1WUkb799KG6vifG0pLgy2DtbzNEHf9Ywp?usp=sharing" target="_blank" rel="noopener external nofollow noreferrer">Collaborative Recommendations Using Item-to-Item Similarity Mappings</a></li><li>书籍: Recommender Systems Handbook(Chapter4)</li></ul></li><li>矩阵分解<ul><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//drive.google.com/drive/folders/1WUkb799KG6vifG0pLgy2DtbzNEHf9Ywp?usp=sharing" target="_blank" rel="noopener external nofollow noreferrer">Matrix Factorization and Collaborative Filtering</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//drive.google.com/drive/folders/1WUkb799KG6vifG0pLgy2DtbzNEHf9Ywp?usp=sharing" target="_blank" rel="noopener external nofollow noreferrer">Factorization Meets the Neighborhood: A Multifaceted Collaborative Filtering Model</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//drive.google.com/drive/folders/1WUkb799KG6vifG0pLgy2DtbzNEHf9Ywp?usp=sharing" target="_blank" rel="noopener external nofollow noreferrer">BPR-Bayesian Personalized Ranking from Implicit Feedback</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//drive.google.com/drive/folders/1WUkb799KG6vifG0pLgy2DtbzNEHf9Ywp?usp=sharing" target="_blank" rel="noopener external nofollow noreferrer">Collborative Filtering for Implicit Feedback Datasets</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//drive.google.com/drive/folders/1WUkb799KG6vifG0pLgy2DtbzNEHf9Ywp?usp=sharing" target="_blank" rel="noopener external nofollow noreferrer">Matrix Factorization techniques For Recommender Systems</a></li></ul></li><li>模型融合<ul><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//research.google.com/pubs/archive/36483.pdf" target="_blank" rel="noopener external nofollow noreferrer">Adaptive Bound Optimization for Online Convex Optmization</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//research.google.com/pubs/archive/41159.pdf" target="_blank" rel="noopener external nofollow noreferrer">Ad Click Prediction: a View from the Trenches</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf" target="_blank" rel="noopener external nofollow noreferrer">Factorization Machines</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//www.csie.ntu.edu.tw/~cjlin/papers/ffm.pdf" target="_blank" rel="noopener external nofollow noreferrer">Field-aware Factorization Machines for CTR Prediction</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!quinonero.net/Publications/predicting-clicks-facebook.pdf" target="_blank" rel="noopener external nofollow noreferrer">Practical Lessons from Prediction Clicks on Ads at Facebook</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//arxiv.org/pdf/1606.07792.pdf" target="_blank" rel="noopener external nofollow noreferrer">Wide &amp; Deep Learning for Recommender Systems</a></li></ul></li><li>深度学习<ul><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//research.google.com/pubs/archive/45530.pdf" target="_blank" rel="noopener external nofollow noreferrer">Deep Neural Networks For YouTube Recommendations</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//arxiv.org/pdf/1301.3781" target="_blank" rel="noopener external nofollow noreferrer">Efficient Estimation of Word Representations in Vector Space</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//arxiv.org/vc/arxiv/papers/1603/1603.04259v2.pdf" target="_blank" rel="noopener external nofollow noreferrer">Item2Vec: Neural Item Embedding for Collaborative Filtering</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//arxiv.org/pdf/1706.06978.pdf" target="_blank" rel="noopener external nofollow noreferrer">Deep Interest Network for Click-Through Rate Prediction</a></li><li>文章: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//mp.weixin.qq.com/s/-OURFdc6WkK5Nbpi0MCnjQ" target="_blank" rel="noopener external nofollow noreferrer">任意深度学习+树状全库检索</a></li></ul></li><li>强化学习<ul><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//arxiv.org/pdf/1801.00209.pdf" target="_blank" rel="noopener external nofollow noreferrer">Deep Reinforcement Learning for List-wise Recommendations</a></li><li>论文: <a href="https://blog.csdn.net/weixin_33978016/article/details/!https%3A//arxiv.org/pdf/1801.00209.pdf" target="_blank" rel="noopener external nofollow noreferrer">A Deep reinforcement Learning Framework for News Recommendation</a></li></ul></li></ul><!-- rebuild by neat --><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>推荐系统</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
</search>
